#include "message_parser.h"

#include <algorithm>

namespace MQTTTopics
{
MessageParser::Variables::Variables(
    {%- for variable in variables -%}
    const std::string& {{ variable }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
) :
    {% for variable in variables -%}
    {{ variable }}({{ variable }})
    {%- if not loop.last %}, {% endif -%}
    {%- endfor %} {}

MessageParser::MessageParser() {
    this->buildTree();
}

void MessageParser::setMessageParse(Topic topic, parse_t parse, void* argument) {
    auto node = this->findNode(this->tree, GetTopic(topic).topic);

    if(node != nullptr) {
        node->parse = std::make_unique<parse_t>(parse);
        
        if(argument != nullptr) {
            node->argument = argument; 
        }
    }
}

void MessageParser::parseMessage(const Variables& variables, const std::string& topic, const std::string& payload) {
    auto nodes = this->findNodesVariables(this->tree, topic, variables);

    for(auto& node : nodes) {
        if(node->parse != nullptr) {
            (*node->parse)(payload, node->argument);
        }
    }
}

void MessageParser::buildTree() {
    {% for topic in topics -%}
    this->addTopic(this->tree, "{{ topic['topic'] }}");
    {%- if not loop.last%}
    {%endif -%}
    {%- endfor %}
}

void MessageParser::addTopic(TopicNode& node, const std::string& topic) {
    if(topic.empty()) {
        return;
    }

    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        iter = node.adjacent.emplace(subTopic, TopicNode()).first;
    }

    if(slash != topic.end()) {
        this->addTopic(iter->second, std::string(slash + 1, topic.end()));
    }
}

MessageParser::TopicNode* MessageParser::findNode(TopicNode& node, const std::string& topic) {
    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        return nullptr;
    } 
    
    if(slash == topic.end()) {
        return &(iter->second);
    } else {
        return findNode(iter->second, std::string(slash + 1, topic.end()));
    }
}

std::vector<MessageParser::TopicNode*> MessageParser::findNodesVariables(TopicNode& node, const std::string& topic, const Variables& variables) {
    std::vector<TopicNode*> ret;
    findNodesVariablesRec(node, topic, variables, false, ret);

    return ret;
}

void MessageParser::findNodesVariablesRec(TopicNode& node, const std::string& topic, const Variables& variables, bool hashtag, std::vector<TopicNode*>& ret) {    
    auto slash = std::find(topic.begin(), topic.end(), '/');
    std::string subTopic = std::string(topic.begin(), slash);

    if(subTopic == "#") {
        hashtag = true;
    }

    if(hashtag) {
        for(auto& next : node.adjacent) {
            ret.push_back(&(next.second));
            findNodesVariablesRec(next.second, "", variables, hashtag, ret);
        }
    } else {
        for(auto& next : node.adjacent) {
            bool match = false;

            if(subTopic == "+" || subTopic == next.first) {
                match = true;
            }
            {%- for variable in variables %} else if(next.first == "<{{ variable }}>" && subTopic == variables.{{ variable }}) {
                match = true;
            }
            {%- endfor %}

            if(match) {
                if(slash == topic.end()) {
                    ret.push_back(&(next.second));
                } else {
                    findNodesVariablesRec(next.second, std::string(slash + 1, topic.end()), variables, hashtag, ret);
                }
            }
        }
    }
}
}