#include "message_parser.h"

#include <algorithm>

namespace MQTTTopics
{

MessageParser::Variables::Variables(
    {%- for variable in variables -%}
    const std::string& {{ variable }}
    {%- if not loop.last %}, {% endif -%}
    {%- endfor -%}
) :
    {% for variable in variables -%}
    {{ variable }}({{ variable }})
    {%- if not loop.last %}, {% endif -%}
    {%- endfor %} {}

MessageParser::MessageParser() {
    this->buildTree();
}

void MessageParser::setMessageParse(Topic topic, parse_t parse, void* argument) {
    auto node = this->findNode(this->tree, GetTopic(topic).topic);

    if(node != nullptr) {
        node->parse = std::make_unique<parse_t>(parse);
        
        if(argument != nullptr) {
            node->argument = argument; 
        }
    }
}

void MessageParser::parseMessage(const Variables& variables, const std::string& topic, const std::string& payload) {
    auto node = this->findNode(this->tree, topic, variables);

    if(node != nullptr) {
        (*node->parse)(payload, node->argument);
    }
}

void MessageParser::buildTree() {
    {% for topic in topics -%}
    this->addTopic(this->tree, "{{ topic['topic'] }}");
    {%- if not loop.last%}
    {%endif -%}
    {%- endfor %}
}

void MessageParser::addTopic(TopicNode& node, const std::string& topic) {
    if(topic.empty()) {
        return;
    }

    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        iter = node.adjacent.emplace(subTopic, TopicNode()).first;
    }

    if(slash != topic.end()) {
        this->addTopic(iter->second, std::string(slash + 1, topic.end()));
    }
}

MessageParser::TopicNode* MessageParser::findNode(TopicNode& node, const std::string& topic) {
    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        return nullptr;
    } 
    
    if(slash == topic.end()) {
        return &(iter->second);
    } else {
        return findNode(iter->second, std::string(slash + 1, topic.end()));
    }
}

MessageParser::TopicNode* MessageParser::findNode(TopicNode& node, const std::string& topic, const Variables& variables) {
    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        iter = std::find_if(node.adjacent.begin(), node.adjacent.end(), [&subTopic, &variables](auto& next) {
            {% for variable in variables -%}
            if(next.first == "<{{ variable }}>" && subTopic == variables.{{ variable }}) {
                return true;
            }
            {%- if not loop.last %} else {% endif -%}
            {%- endfor %} else {
                return false;
            }
        });
    }

    if(iter == node.adjacent.end()) {
        return nullptr;
    } 
    
    if(slash == topic.end()) {
        return &(iter->second);
    } else {
        return findNode(iter->second, std::string(slash + 1, topic.end()), variables);
    }
}
}