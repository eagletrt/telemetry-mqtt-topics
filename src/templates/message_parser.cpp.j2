#include "message_parser.h"

#include <algorithm>

namespace MQTTTopics
{
MessageParser::MessageParser() {
    this->buildTree();
}

void MessageParser::setMessageParse(const std::string& topic, parse_t parse, void* argument) {
    auto node = this->findNode(this->tree, topic);

    if(node != nullptr) {
        (*node)->parse = std::make_unique<parse_t>(parse);
        
        if(argument != nullptr) {
            (*node)->argument = argument; 
        }
    }
}

void MessageParser::parseMessage(const std::string& topic, const std::string& payload) {
    auto node = this->findNode(this->tree, topic);

    if(node != nullptr) {
        (*(*node)->parse)(payload, (*node)->argument);
    }
}

void MessageParser::buildTree() {
    this->tree = std::make_unique<TopicNode>(TopicNode());
    {% for topic in topics -%}
    this->addTopic(this->tree, "{{ topic['topic'] }}");
    {%- if not loop.last%}
    {%endif -%}
    {%- endfor %}
}

void MessageParser::addTopic(std::unique_ptr<TopicNode>& node, const std::string& topic) {
    if(topic.empty()) {
        return;
    }

    auto slash = std::find(topic.begin(), topic.end(), '/');
    std::string subTopic = std::string(topic.begin(), slash + 1);
    auto iter = node->adjacent.find(subTopic);

    if(iter == node->adjacent.end()) {
        iter = node->adjacent.emplace(subTopic, std::make_unique<TopicNode>(TopicNode())).first;
    }

    this->addTopic(iter->second, std::string(slash, topic.end()));
}

std::unique_ptr<MessageParser::TopicNode>* MessageParser::findNode(std::unique_ptr<TopicNode>& node, const std::string& topic) {
    auto slash = std::find(topic.begin(), topic.end(), '/');

    if(slash == topic.end()) {
        return &node;
    }

    std::string subTopic = std::string(topic.begin(), slash + 1);
    auto iter = node->adjacent.find(subTopic);

    if(iter == node->adjacent.end()) {
        iter = std::find_if(node->adjacent.begin(), node->adjacent.end(), [](auto& p) {
            return ((p.first.front() == '<') && (p.first.back() == '>'));
        });
    }

    if(iter == node->adjacent.end()) {
        return nullptr;
    } 
    
    return findNode(iter->second, subTopic);
}
}