#include "message_parser.h"

#include <algorithm>

namespace MQTTTopics
{
MessageParser::MessageParser() {
    this->buildTree();
}

void MessageParser::setMessageParse(Topic topic, parse_t parse, void* argument) {
    auto node = this->findNode(this->tree, GetTopic(topic).topic);

    if(node != nullptr) {
        node->parse = std::make_unique<parse_t>(parse);
        
        if(argument != nullptr) {
            node->argument = argument; 
        }
    }
}

void MessageParser::parseMessage(const std::string& topic, const std::string& payload) {
    auto node = this->findNode(this->tree, topic);

    if(node != nullptr) {
        (*node->parse)(payload, node->argument);
    }
}

void MessageParser::buildTree() {
    {% for topic in topics -%}
    this->addTopic(this->tree, "{{ topic['topic'] }}");
    {%- if not loop.last%}
    {%endif -%}
    {%- endfor %}
}

void MessageParser::addTopic(TopicNode& node, const std::string& topic) {
    if(topic.empty()) {
        return;
    }

    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        iter = node.adjacent.emplace(subTopic, TopicNode()).first;
    }

    if(slash != topic.end()) {
        this->addTopic(iter->second, std::string(slash + 1, topic.end()));
    }
}

MessageParser::TopicNode* MessageParser::findNode(TopicNode& node, const std::string& topic) {
    auto slash = std::find(topic.begin(), topic.end(), '/');

    std::string subTopic = std::string(topic.begin(), slash);
    auto iter = node.adjacent.find(subTopic);

    if(iter == node.adjacent.end()) {
        iter = std::find_if(node.adjacent.begin(), node.adjacent.end(), [](auto& p) {
            return ((p.first.front() == '<') && (p.first.back() == '>'));
        });
    }

    if(iter == node.adjacent.end()) {
        return nullptr;
    } 
    
    if(slash == topic.end()) {
        return &(iter->second);
    } else {
        return findNode(iter->second, std::string(slash + 1, topic.end()));
    }
}
}